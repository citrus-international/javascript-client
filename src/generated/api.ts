import * as $ from 'jquery';

let defaultBasePath = 'https://integration.citrusad.com/v1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class BatchCatalogUpdateRequest {
    'storeId': string;
    'products': Array<Product>;
}

export class BatchCustomerUpdateRequest extends Array<BatchCustomerUpdateRequestInner> {
}

export class BatchCustomerUpdateRequestInner {
    'storeId': string;
    'customers': Array<Customer>;
}

export class BatchRegisterPurchaseRequest {
    'orders': Array<BatchRegisterPurchaseRequestOrders>;
}

export class BatchRegisterPurchaseRequestOrders {
    'orderId': string;
    'productAdInstanceIds': Array<string>;
}

export class BrowserContext {
    'userAgent': string;
}

export class ContextInformation {
    'userId': string;
    'searchTerm': string;
    'categoryHierarchy': string;
    'substitutedProductGtin': string;
    'pageType': ContextInformation.PageTypeEnum;
    'currentCartItems': Array<OrderItem>;
    'maxNumberOfAds': number;
    'browserContext': BrowserContext;
}

export namespace ContextInformation {
    export enum PageTypeEnum {
            Home = <any> 'Home',
            Category = <any> 'Category',
            Search = <any> 'Search',
            Specials = <any> 'Specials',
            PastOrder = <any> 'PastOrder',
            Substitution = <any> 'Substitution'
    }
}
export class Customer {
    'customerId': string;
    'orders': Array<Order>;
    'yearOfBirth': number;
    'gender': Customer.GenderEnum;
    'suburb': string;
    'postcode': string;
}

export namespace Customer {
    export enum GenderEnum {
            Male = <any> 'Male',
            Female = <any> 'Female',
            Other = <any> 'Other'
    }
}
export class GenerateAdResponse {
    'isSuccessful': boolean;
    'errorMessages': Array<GenericResponseErrorMessages>;
    'ads': Array<ProductAdInstance>;
}

export class GenericResponse {
    'isSuccessful': boolean;
    'errorMessages': Array<GenericResponseErrorMessages>;
}

export class GenericResponseErrorMessages {
    'message': string;
    'code': number;
}

export class Order {
    'orderDate': string;
    'orderItems': Array<OrderItem>;
}

export class OrderItem {
    'gtin': string;
    'quantity': number;
    'regularUnitPrice': number;
    'totalOrderItemPriceAfterDiscounts': number;
    'substitutedFor': OrderItem;
}

export class Product {
    'gtin': string;
    'name': string;
    'images': Array<string>;
    'category': string;
    'regularPrice': number;
}

export class ProductAdInstance {
    'id': string;
    'gtin': string;
    'price': number;
}

export class ProductAdInstanceResponse {
    'isSuccessful': boolean;
    'errorMessages': Array<GenericResponseErrorMessages>;
    'proudctAdInstance': ProductAdInstance;
}


export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: JQueryAjaxSettings): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: any): void {
        requestOptions.username = this.username;
        requestOptions.password = this.password;
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: JQueryAjaxSettings): void {
        requestOptions.headers[this.paramName] = this.apiKey;
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: JQueryAjaxSettings): void {
        requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: JQueryAjaxSettings): void {
        // Do nothing
    }
}

export enum DefaultApiApiKeys {
    TokenSecurity,
}

export class DefaultApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};

    protected authentications : {[key:string]:Authentication} = {
        'default': <Authentication>new VoidAuth(),
        'TokenSecurity': new ApiKeyAuth('header', 'token'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    public setApiKey(key: DefaultApiApiKeys, value: string) {
        var auth = this.authentications[DefaultApiApiKeys[key]]
        if (auth instanceof ApiKeyAuth) {
          auth.apiKey = value;
        }
    }
    private extendObj<T1, T2 extends T1>(objA: T2, objB: T2): T1|T2 {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
            objA[key] = objB[key];
            }
        }
        return objA;
    }

    /**
     * Gets ad instance information
     * Gets ad instance information
     * @param productAdInstanceId 
     */
    public getProductAdInstance (productAdInstanceId: string) : JQueryPromise<{ response: JQueryXHR; body: ProductAdInstanceResponse;  }> {
        let localVarPath = this.basePath + '/ad/{productAdInstanceId}'
            .replace('{' + 'productAdInstanceId' + '}', String(productAdInstanceId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);


        // verify required parameter 'productAdInstanceId' is not null or undefined
        if (productAdInstanceId === null || productAdInstanceId === undefined) {
            throw new Error('Required parameter productAdInstanceId was null or undefined when calling getProductAdInstance.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);


        let reqHasFile = false;
        let reqDict = {};
        let reqFormData = new FormData();

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (Object.keys(reqDict).length) {
            requestOptions.data = reqHasFile ? reqFormData : JSON.stringify(reqDict);
            requestOptions.contentType = reqHasFile ? false : 'application/json; charset=utf-8';
        }

        this.authentications.TokenSecurity.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        let dfd = $.Deferred();
        $.ajax(requestOptions).then(
            (data: ProductAdInstanceResponse, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({ response: jqXHR, body: data }),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({ response: xhr, body: errorThrown })
        );
        return dfd.promise();
    }
    /**
     * Register a click for an ad
     * 
     * @param productAdInstanceId 
     */
    public registerClick (productAdInstanceId: string) : JQueryPromise<{ response: JQueryXHR; body: GenericResponse;  }> {
        let localVarPath = this.basePath + '/ad/{productAdInstanceId}/click'
            .replace('{' + 'productAdInstanceId' + '}', String(productAdInstanceId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);


        // verify required parameter 'productAdInstanceId' is not null or undefined
        if (productAdInstanceId === null || productAdInstanceId === undefined) {
            throw new Error('Required parameter productAdInstanceId was null or undefined when calling registerClick.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);


        let reqHasFile = false;
        let reqDict = {};
        let reqFormData = new FormData();

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (Object.keys(reqDict).length) {
            requestOptions.data = reqHasFile ? reqFormData : JSON.stringify(reqDict);
            requestOptions.contentType = reqHasFile ? false : 'application/json; charset=utf-8';
        }

        this.authentications.TokenSecurity.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        let dfd = $.Deferred();
        $.ajax(requestOptions).then(
            (data: GenericResponse, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({ response: jqXHR, body: data }),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({ response: xhr, body: errorThrown })
        );
        return dfd.promise();
    }
    /**
     * Registers purchases against previously clicked ads
     * Registers purchases against previously clicked ads
     * @param registerPurchaseRequest 
     */
    public registerPurchase (registerPurchaseRequest: BatchRegisterPurchaseRequest) : JQueryPromise<{ response: JQueryXHR; body: GenericResponse;  }> {
        let localVarPath = this.basePath + '/ad/purchase';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);


        // verify required parameter 'registerPurchaseRequest' is not null or undefined
        if (registerPurchaseRequest === null || registerPurchaseRequest === undefined) {
            throw new Error('Required parameter registerPurchaseRequest was null or undefined when calling registerPurchase.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);


        let reqDict = registerPurchaseRequest;
        let reqFormData = new FormData();
        let reqHasFile = false;

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (Object.keys(reqDict).length) {
            requestOptions.data = reqHasFile ? reqFormData : JSON.stringify(reqDict);
            requestOptions.contentType = reqHasFile ? false : 'application/json; charset=utf-8';
        }

        this.authentications.TokenSecurity.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        let dfd = $.Deferred();
        $.ajax(requestOptions).then(
            (data: GenericResponse, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({ response: jqXHR, body: data }),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({ response: xhr, body: errorThrown })
        );
        return dfd.promise();
    }
    /**
     * Reqeust for ads
     * 
     * @param context 
     */
    public requestAd (context: ContextInformation) : JQueryPromise<{ response: JQueryXHR; body: GenerateAdResponse;  }> {
        let localVarPath = this.basePath + '/ad/generate';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);


        // verify required parameter 'context' is not null or undefined
        if (context === null || context === undefined) {
            throw new Error('Required parameter context was null or undefined when calling requestAd.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);


        let reqDict = context;
        let reqFormData = new FormData();
        let reqHasFile = false;

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (Object.keys(reqDict).length) {
            requestOptions.data = reqHasFile ? reqFormData : JSON.stringify(reqDict);
            requestOptions.contentType = reqHasFile ? false : 'application/json; charset=utf-8';
        }

        this.authentications.TokenSecurity.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        let dfd = $.Deferred();
        $.ajax(requestOptions).then(
            (data: GenerateAdResponse, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({ response: jqXHR, body: data }),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({ response: xhr, body: errorThrown })
        );
        return dfd.promise();
    }
    /**
     * Update store catalog information for one or multiple stores.
     * Update store catalog information for one or multiple stores.
     * @param catalogUpdateInfo 
     */
    public updateCatalogs (catalogUpdateInfo: BatchCatalogUpdateRequest) : JQueryPromise<{ response: JQueryXHR; body: GenericResponse;  }> {
        let localVarPath = this.basePath + '/catalog/update';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);


        // verify required parameter 'catalogUpdateInfo' is not null or undefined
        if (catalogUpdateInfo === null || catalogUpdateInfo === undefined) {
            throw new Error('Required parameter catalogUpdateInfo was null or undefined when calling updateCatalogs.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);


        let reqDict = catalogUpdateInfo;
        let reqFormData = new FormData();
        let reqHasFile = false;

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (Object.keys(reqDict).length) {
            requestOptions.data = reqHasFile ? reqFormData : JSON.stringify(reqDict);
            requestOptions.contentType = reqHasFile ? false : 'application/json; charset=utf-8';
        }

        this.authentications.TokenSecurity.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        let dfd = $.Deferred();
        $.ajax(requestOptions).then(
            (data: GenericResponse, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({ response: jqXHR, body: data }),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({ response: xhr, body: errorThrown })
        );
        return dfd.promise();
    }
    /**
     * Update customer information for one or multiple stores.
     * Update customer information for one or multiple stores.
     * @param customerUpdateInfo 
     */
    public updateCustomers (customerUpdateInfo: BatchCustomerUpdateRequest) : JQueryPromise<{ response: JQueryXHR; body: GenericResponse;  }> {
        let localVarPath = this.basePath + '/customer/update';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);


        // verify required parameter 'customerUpdateInfo' is not null or undefined
        if (customerUpdateInfo === null || customerUpdateInfo === undefined) {
            throw new Error('Required parameter customerUpdateInfo was null or undefined when calling updateCustomers.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);


        let reqDict = customerUpdateInfo;
        let reqFormData = new FormData();
        let reqHasFile = false;

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (Object.keys(reqDict).length) {
            requestOptions.data = reqHasFile ? reqFormData : JSON.stringify(reqDict);
            requestOptions.contentType = reqHasFile ? false : 'application/json; charset=utf-8';
        }

        this.authentications.TokenSecurity.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        let dfd = $.Deferred();
        $.ajax(requestOptions).then(
            (data: GenericResponse, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({ response: jqXHR, body: data }),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({ response: xhr, body: errorThrown })
        );
        return dfd.promise();
    }
}
